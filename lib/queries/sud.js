// Generated by CoffeeScript 1.4.0
var And, BaseQuery, CONST_NODES, Column, Node, Or, Ordering, SUDQuery, deprecate, fluid, method, nodes, toField, variadic, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseQuery = require('./base');

nodes = require('../nodes');

Node = nodes.Node, And = nodes.And, Or = nodes.Or, Ordering = nodes.Ordering, Column = nodes.Column, CONST_NODES = nodes.CONST_NODES, toField = nodes.toField;

module.exports = SUDQuery = (function(_super) {

  __extends(SUDQuery, _super);

  function SUDQuery() {
    return SUDQuery.__super__.constructor.apply(this, arguments);
  }

  /*
    SUDQuery is the base class for SELECT, UPDATE, and DELETE queries. It adds
    logic to :class:`queries/base::BaseQuery` for adding WHERE clauses, projecting
    columns, ordering, limits, and offsets.
  */


  SUDQuery.prototype.where = function(constraint) {
    /*
        Adds a WHERE clause to the query. This method accepts wide range of input
        that can express very complex constraints. The examples below assume we are
        starting with this simple select query: ``q = select('t1')``
    
        The first kind of constraint is a comparison node as produced by the
        :class:`nodes::ComparableMixin` methods on projected fields::
    
          q.where(q.c('field1').eq(42))
          q.where(q.c('field2').gt(42))
          # WHERE t1.field1 = 42 AND t1.field2 > 42
    
        We used an implied table name above, which is always the last table added to
        the query or focused with  :meth:`queries/sud::SUDQuery.focus`. If you want
        to specify constraints on multiple tables at once (or just be more explicit)
        you can also specify the relation for a field by prepending it to the field
        name (e.g. ``q.c('t1.field1')``. See :meth:`queries/sud::SUDQuery.project`
        for details.
    
        The second kind of constraint is an object literal where each key is a field
        name and each value is a constraint. The last example expressed as a literal
        object looks like this::
    
          q.where({field1: 42, field2: {gt: 42}})
          # WHERE t1.field1 = 42 AND t1.field2 > 42
    
        Internally this constructs the comparison nodes for you using a simple
        transformation: each key is passed to :meth:`project` (meaning you can
        specify the relation name as part of the key if you so desire) and each
        value is either used as the argument to :meth:`nodes::ComparableMixin.eq`
        or (in the case of object literals) converted into one or more calls to
        the corresponding comparison methods.
    
        To compare two fields, use a projection as the value to be compared::
    
          p = q.project.bind(q, 't1')
          q.where({field1: {gt: p('field2')}})
          # WHERE t1.field1 > t1.field2
    
        If you use either of the special keys ``'and'`` or ``'or'`` in an object,
        the value will be treated as a nested set of constraints to be joined with
        the corresponding SQL operator. This process is recursive so you can nest
        constraints arbitrarily deep::
    
          q.where({or: {a: 1, and: {b: 2, c: 3}}})
          # WHERE (t1.a = 1 OR (t1.b = 2 AND t1.c = 3))
    
        You can also acheive the same effect by chaining method calls on comparison
        nodes::
    
          a = q.c('a')
          b = q.c('b')
          c = q.c('c')
          q.where(a.eq(1).or(b.eq(2).and(c.eq(3))))
          # WHERE (t1.a = 1 OR (t1.b = 2 AND t1.c = 3))
    
        If you have the need to mix both styles (or simply find it more readable,
        You can use an array of constraints as the value for ``'or'`` or ``'and'``::
    
          q.where({or: [{a: 1}, b.eq(2).and(c.eq(3))]})
    
        Note that currently you **cannot** pass an object literal to the ``.and``
        and ``.or`` methods::
    
          # Will not work!!
          q.where(a.eq(1).or({b: 2, c: 3}))
    
        Finally, there are also shortcut methods :meth:`queries/sud::SUDQuery.and`
        and :meth:`queries/sud::SUDQuery.or` that treat multiple arguments like an
        array of constraints.
    */

    var node, _i, _len, _ref, _results;
    _ref = this._makeClauses(constraint);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      _results.push(this.q.where.addNode(node));
    }
    return _results;
  };

  SUDQuery.prototype._makeClauses = function(constraint) {
    /*
        Return an array of Binary, And, and Or nodes for this constraint object
    */

    var clauses, column, field, item, op, predicate, val, _i, _len;
    clauses = [];
    if (Array.isArray(constraint)) {
      for (_i = 0, _len = constraint.length; _i < _len; _i++) {
        item = constraint[_i];
        if (item instanceof Node) {
          clauses.push(item);
        } else {
          clauses = clauses.concat(this._makeClauses(item));
        }
      }
      return clauses;
    }
    if (constraint instanceof Node) {
      return [constraint];
    }
    for (field in constraint) {
      predicate = constraint[field];
      if (field === 'and') {
        clauses.push(new And(this._makeClauses(predicate)));
      } else if (field === 'or') {
        clauses.push(new Or(this._makeClauses(predicate)));
      } else {
        column = this.column(field);
        if (predicate === null) {
          clauses.push(column.compare('IS', CONST_NODES.NULL));
        } else if (predicate.constructor === Object) {
          for (op in predicate) {
            val = predicate[op];
            clauses.push(column.compare(op, val));
          }
        } else {
          clauses.push(column.eq(predicate));
        }
      }
    }
    return clauses;
  };

  SUDQuery.prototype.or = function(clauses) {
    /* Shortcut for ``.where({or: clauses})``
    */
    return this.where({
      or: clauses
    });
  };

  SUDQuery.prototype.and = function(clauses) {
    /* Shortcut for ``.where({and: clauses})``
    */
    return this.where({
      and: clauses
    });
  };

  SUDQuery.prototype.order = function(args) {
    /*
        Add one or more ORDER BY clauses to the query.
    
        Each ordering can either be a string, in which case it must be a valid-ish
        SQL snippet like 'some_table.some_field DESC', (the field name and direction
        will still be converted to AST nodes) or an object, in which case each key
        will be treated as a field and each value as a direction.
    */

    var dir, direction, field, name, orderBy, orderings, rel, _i, _j, _len, _len1, _ref, _results;
    rel = this.defaultRel();
    orderings = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      orderBy = args[_i];
      switch (orderBy.constructor) {
        case String:
          orderings.push(orderBy.split(' '));
          break;
        case Ordering:
          this.q.orderBy.addNode(orderBy);
          break;
        case Object:
          for (name in orderBy) {
            dir = orderBy[name];
            orderings.push([name, dir]);
          }
          break;
        default:
          throw new Error("Can't turn " + orderBy + " into an ordering");
      }
    }
    _results = [];
    for (_j = 0, _len1 = orderings.length; _j < _len1; _j++) {
      _ref = orderings[_j], field = _ref[0], direction = _ref[1];
      direction = (function() {
        switch ((direction || '').toLowerCase()) {
          case 'asc':
          case 'ascending':
            return 'ASC';
          case 'desc':
          case 'descending':
            return 'DESC';
          case '':
            return '';
          default:
            throw new Error("Unsupported ordering direction " + direction);
        }
      })();
      _results.push(this.q.orderBy.addNode(new Ordering(this.column(field), direction)));
    }
    return _results;
  };

  SUDQuery.prototype.limit = function(l) {
    /* Set the LIMIT on this query
    */
    return this.q.limit.value = l;
  };

  SUDQuery.prototype.offset = function(l) {
    /* Set the OFFSET of this query
    */
    return this.q.offset.value = l;
  };

  SUDQuery.prototype.defaultRel = function() {
    return this.q.relations.active;
  };

  SUDQuery.prototype.project = function() {
    /* Backwards compatible alias for :meth:`queries/sud::SUDQuery.column`
    */
    return this.column.apply(this, arguments);
  };

  SUDQuery.prototype.column = function(relation, field) {
    /*
        Return a :class:`nodes::Column` node representing ``<relation>.<field>``.
    
        The first argument is optional and specifies a table or alias name referring
        to a relation already joined to this query. If you don't specify a relation,
        the table added or focused last will be used. Alternatively, you can specify
        the relation name and field with a single dot-separated string::
    
          q.column('departments.name') == q.column('departments', 'name')
    
        The returned object has a methods from :class:`nodes::ComparableMixin` that
        create new comparison nodes usable in join conditions and where clauses::
    
          # Find developers over the age of 45
          s = select('people', ['name'])
          s.join('departments', on: {id: s.column('people', 'department_id')})
          s.where(s.column('departments', 'name').eq('development'))
          s.where(s.column('people', 'age').gte(45))
    
        ``project`` is also aliased as ``p`` for those who value brevity::
    
             q.where(q.c('departments.name').eq('development'))
    
        .. note:: this means you *must* specify a relation name if you have a field
          name with a dot in it, if you have dots in your column names, sorry.
    */

    var parts, proj, _ref;
    if (field != null) {
      field = toField(field);
      if (typeof relation === 'string') {
        return new Column(this.q.relations.get(relation), field);
      } else {
        relation = this.q.relations.get(toRelation(relation).ref());
        return new Column(relation, field);
      }
    } else if (typeof relation === 'string') {
      parts = relation.split('.');
      if (parts.length === 2) {
        return new Column(this.q.relations.get(parts[0]), toField(parts[1]));
      } else {
        return new Column(this.defaultRel(), toField(relation));
      }
    } else if (relation instanceof Column) {
      proj = relation;
      this.q.relations.get((_ref = proj.source) != null ? _ref.ref() : void 0);
      return proj;
    } else {
      throw new Error("Can't make a projection from object: " + relation);
    }
  };

  SUDQuery.prototype.rel = function(alias) {
    /* A shorthand way to get a relation by (alias) name
    */
    return this.q.relations.get(alias);
  };

  return SUDQuery;

})(BaseQuery);

deprecate = require('../decorators/deprecate');

variadic = require('../decorators/variadic');

fluid = require('../decorators/fluid');

_ref = ['and', 'or', 'order'];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  method = _ref[_i];
  SUDQuery.prototype[method] = variadic(SUDQuery.prototype[method]);
}

_ref1 = ['where', 'or', 'and', 'limit', 'offset', 'order'];
for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
  method = _ref1[_j];
  SUDQuery.prototype[method] = fluid(SUDQuery.prototype[method]);
}

_ref2 = ['p', 'project'];
for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
  method = _ref2[_k];
  SUDQuery.prototype[method] = deprecate.rename(SUDQuery.prototype.column, method, ".column or .c");
}

SUDQuery.prototype.c = SUDQuery.prototype.column;
