// Generated by CoffeeScript 1.4.0
/*
The factory functions defined here create instances of the corresponding
`*Query` manager classes, which fit the following inheritance hierarchy:

  * BaseQuery

    * InsertQuery

    * SUDQuery

      * SelectQuery

      * UpdateQuery

      * DeleteQuery

.. _query-factories:

These functions are the same ones re-exported by the main gesundheit module
(where they bind queries to ``gesundheit.defaultEngine``), and attached to
engine/transaction objects (where they bind queries to the engine/transaction
they are called on).

Each one accepts a table name or alias object (anything handled by
:func:`nodes::toRelation`), one or more extra parameters, and an optional
visitor callback as a final parameter that will be called with it's ``this``
context set to the newly constructed query instance.
*/

var DELETE, DeleteQuery, INSERT, InsertQuery, SELECT, SelectQuery, UPDATE, UpdateQuery, maybeVisit;

InsertQuery = require('./insert');

SelectQuery = require('./select');

UpdateQuery = require('./update');

DeleteQuery = require('./delete');

INSERT = function(table, fieldsOrRow) {
  /*
    Create a new :class:`queries/insert::InsertQuery` that will add rows to
    ``table``.
  
    :param table: Name of the table that rows will be inserted into.
    :param fieldsOrRow: Either an array of column names that will be inserted, or a
      plain object representing a row of data to insert, in which case the keys
      of the object will define the columns that are inserted.
    :param visitor: (Optional) a function that will be called with it's context
      set to the newly constructed query object.
  
    .. warning::
      The column names passed in ``fields`` will be printed into the query
      **unescaped** so do **not** use arbitrary input here. This is hopefully only temporary.
  */

  var fields, iq, row;
  if (Array.isArray(fieldsOrRow)) {
    fields = fieldsOrRow;
  } else if (typeof fieldsOrRow === 'object') {
    row = fieldsOrRow;
    fields = Object.keys(row);
  }
  iq = new InsertQuery(this, {
    table: table,
    fields: fields
  });
  if (row) {
    iq.addRow(row);
  }
  return iq;
};

SELECT = function(table, fields) {
  /*
    Create a new :class:`queries/select::SelectQuery` selecting from ``table``.
  
    :param table: Name or alias object of the first table to select rows from.
      More tables can be joined using :meth:`queries/select::SelectQuery.join`.
    :param fields: (Optional) Fields to project from ``table``. If this is not
      given, all fields (``*``) will be projected until
      :meth:`queries/select::SelectQuery.fields` is called.
    :param visitor: (Optional) a function that will be called with it's context
      set to the newly constructed query object.
  */

  var query;
  query = new SelectQuery(this, {
    table: table
  });
  if (fields != null) {
    query.fields.apply(query, fields);
  }
  return query;
};

UPDATE = function(table) {
  /*
    Create a new :class:`queries/update::UpdateQuery` that will update ``table``.
  
    :param table: Name or alias of the table to update.
    :param visitor: (Optional) a function that will be called with it's context
      set to the newly constructed query object.
  */
  return new UpdateQuery(this, {
    table: table
  });
};

DELETE = function(table) {
  /*
    Create a new :class:`queries/delete::DeleteQuery` that will delete rows from
    ``table``.
  
    :param table: Name or alias of the table to delete rows from.
    :param visitor: (Optional) a function that will be called with it's context
      set to the newly constructed query object.
  */
  return new DeleteQuery(this, {
    table: table
  });
};

exports.mixinFactoryMethods = function(invocant, getEngine) {
  /*
    Add wrappers methods for each of the query factory functions to ``invocant``
    using lower, UPPER, and Camel cases. The new methods will retrieve an engine
    using ``getEngine`` and then create the query bound to that engine.
  
    If ``getEngine`` is not given, queries will be bound to ``invocant`` instead.
  */

  var factory, type, _fn, _ref;
  if (getEngine == null) {
    getEngine = function() {
      return invocant;
    };
  }
  _ref = {
    INSERT: INSERT,
    SELECT: SELECT,
    UPDATE: UPDATE,
    DELETE: DELETE
  };
  _fn = function(type, factory) {
    var wrapper;
    factory = maybeVisit(factory);
    wrapper = function() {
      return factory.apply(getEngine(), arguments);
    };
    invocant[type] = wrapper;
    invocant[type.toLowerCase()] = wrapper;
    return invocant[type[0] + type.toLowerCase().substring(1)] = wrapper;
  };
  for (type in _ref) {
    factory = _ref[type];
    _fn(type, factory);
  }
  return invocant;
};

maybeVisit = function(func) {
  return function() {
    var a, cb;
    a = [].slice.call(arguments);
    if (typeof a[a.length - 1] === 'function') {
      cb = a.pop();
      return func.apply(this, a).visit(cb);
    } else {
      return func.apply(this, a);
    }
  };
};
