// Generated by CoffeeScript 1.4.0
var BaseQuery, EventEmitter, assert, fluid, inspect, method, toRelation, _i, _len, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

inspect = require('util').inspect;

EventEmitter = require('events').EventEmitter;

toRelation = require('../nodes').toRelation;

assert = require('assert');

module.exports = BaseQuery = (function(_super) {

  __extends(BaseQuery, _super);

  /*
    The base class for all queries. While this class itself is not part of
    gesundheits public API, the methods defined on it are.
  */


  BaseQuery.rootNode = null;

  function BaseQuery(engine, opts) {
    if (opts == null) {
      opts = {};
    }
    /*
        :param engine: The engine the query will be bound to.
    
        :param opts.table:
          Any object that can be converted by :func:`nodes::toRelation`.
    */

    this.bind(engine);
    this.q = opts.rootNode || new this.constructor.rootNode(opts);
  }

  BaseQuery.prototype.copy = function() {
    /* Instantiate a new query with a deep copy of this ones AST
    */
    return new this.constructor(this.engine, {
      rootNode: this.q.copy()
    });
  };

  BaseQuery.prototype.visit = function(fn) {
    /*
        Call the given function in the context of this query. This is useful with
        query factory functions where you can use it as a sort-of-DSL::
    
            SELECT('people', ['name'], function(q) {
              // this === q
              this.join('addresses', {
                on: {person_id: q.project('people', 'id')},
                fields: ['city', 'region']
              })
            })
    */
    return fn.call(this);
  };

  BaseQuery.prototype.bind = function(engine) {
    /*
        Bind this query object to a new engine.
        If no argument is given the query will be bound to the default engine.
    */

    var oldEngine, _base, _ref, _ref1;
    oldEngine = this.engine;
    this.engine = engine || require('../').defaultEngine;
    if (this.engine !== oldEngine) {
      if (oldEngine != null) {
        if (typeof oldEngine.unextendQuery === "function") {
          oldEngine.unextendQuery(this);
        }
      }
      if (typeof (_base = this.engine).extendQuery === "function") {
        _base.extendQuery(this);
      }
    }
    assert((_ref = this.engine) != null ? _ref.query : void 0, "Engine has no query method: " + (inspect(this.engine)));
    return assert((_ref1 = this.engine) != null ? _ref1.compile : void 0, "Engine has no compile method: " + (inspect(this.engine)));
  };

  BaseQuery.prototype.render = function() {
    /*
        Render the query to a SQL string.
    */
    return this.compile()[0];
  };

  BaseQuery.prototype.compile = function() {
    /*
        Compile this query object, returning a SQL string and parameter array.
    */
    return this.engine.compile(this.q);
  };

  BaseQuery.prototype.execute = function(cb) {
    /*
        Execute the query using ``@engine`` and return a `QueryAdapter`.
    
        :param cb: An (optional) node-style callback that will be called with any
          errors and/or the query results. If no callback is given, an `AnyDB Query`_
          will be returned.
    
        .. _AnyDB Query: https://github.com/grncdr/node-any-db/blob/master/DESIGN.md#query-adapters
    */

    var args, emitter;
    try {
      args = this.compile();
      args.push(cb);
    } catch (err) {
      emitter = new EventEmitter;
      process.nextTick(function() {
        if (cb) {
          return cb(err);
        } else {
          return emitter.emit('error', err);
        }
      });
      return emitter;
    }
    return this.engine.query.apply(this.engine, args);
  };

  BaseQuery.prototype.toString = function() {
    return this.render();
  };

  return BaseQuery;

})(EventEmitter);

fluid = require('../decorators/fluid');

_ref = ['bind', 'visit'];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  method = _ref[_i];
  BaseQuery.prototype[method] = fluid(BaseQuery.prototype[method]);
}
