// Generated by CoffeeScript 1.4.0
var And, JOIN_TYPES, Join, Node, SUDQuery, Select, SelectQuery, deprecate, fluid, getAlias, method, sqlFunction, toRelation, variadic, _i, _j, _len, _len1, _ref, _ref1, _ref2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

SUDQuery = require('./sud');

_ref = require('../nodes'), Node = _ref.Node, getAlias = _ref.getAlias, Select = _ref.Select, And = _ref.And, Join = _ref.Join, toRelation = _ref.toRelation, sqlFunction = _ref.sqlFunction, JOIN_TYPES = _ref.JOIN_TYPES;

module.exports = SelectQuery = (function(_super) {

  __extends(SelectQuery, _super);

  /*
    Adds a number of SELECT-specific methods to :class:`queries/sud::SUDQuery`,
    such as `fields` and `groupBy`
  */


  function SelectQuery() {
    return SelectQuery.__super__.constructor.apply(this, arguments);
  }

  SelectQuery.rootNode = Select;

  SelectQuery.prototype.fields = function(fields) {
    /*
        Adds one or more fields to the query. Fields can be strings (in which case
        they will be passed to :meth:`queries/sud::SUDQuery.column`) or pre-
        constructed nodes. (Such as those returned by ``column``).
    
        If no fields are given, clears all fields from the currently focused table.
    
        To alias a field, use an object with a single key where the key is the alias
        name and the value is a string or node::
    
          q.fields({employee_name: 'employees.name'})
    */

    var alias, col, f, rel, _i, _len,
      _this = this;
    if (fields.length === 0) {
      rel = this.q.relations.active;
      this.q.projections.prune(function(p) {
        return p.rel() === rel;
      });
      return;
    }
    col = function(o) {
      if (o instanceof Node) {
        return o;
      } else {
        return _this.column(o);
      }
    };
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      f = fields[_i];
      if (alias = getAlias(f)) {
        f = f[alias];
        this.q.projections.addNode(col(f).as(alias));
      } else {
        this.q.projections.addNode(col(f));
      }
    }
    return null;
  };

  SelectQuery.prototype.func = function(fun, args) {
    /*
        Adds a SQL function to the column list for the query. This can be an
        aggregate function if you also use :meth:`queries/select::groupBy`.
    
        :param fun: name of SQL function.
        :param args: arguments that will be passed to the function. Any argument
          that is not a `Node` object will be converted into a bound parameter.
    
        Example::
    
          # SELECT count(id) FROM t1
          select('t1', function (q) { q.func('count', q.c('id')) })
    
          # SELECT count(id) AS "counter" FROM t1
          select('t1', function (q) { q.func({counter: 'count'}, q.c('id')) })
    */

    var alias;
    if (alias = getAlias(fun)) {
      return this.q.projections.addNode(sqlFunction(fun[alias], args).as(alias));
    } else {
      return this.q.projections.addNode(sqlFunction(fun, args));
    }
  };

  SelectQuery.prototype.distinct = function(bool) {
    /*
        Make this query DISTINCT on *all* fields.
    */
    return this.q.distinct.enable = bool;
  };

  SelectQuery.prototype.join = function(table, opts) {
    var join, rel, type;
    if (opts == null) {
      opts = {};
    }
    /*
        Join another table to the query.
    
        :param table: A table name, or alias literal. An error will be thrown if
          the table/alias name is not unique. See :func:`nodes::toRelation` for
          more information on the many things ``table`` could be.
        :param opts.on:
          An object literal expressing join conditions. See
          :meth:`queries/select::SelectQuery::where` for more.
        :param opts.type: A join type constant (e.g. INNER, OUTER)
        :param opts.fields: Columns to be selected from the newly joined table.
    */

    rel = toRelation(table);
    if (this.q.relations.get(rel.ref(), false)) {
      throw new Error("Table/alias " + (rel.ref()) + " is not unique!");
    }
    type = opts.type || JOIN_TYPES.INNER;
    if (!(type instanceof JOIN_TYPES.INNER.constructor)) {
      throw new Error("Invalid join type " + type + ", try the constant types exported in the base module (e.g. INNER).");
    }
    join = new Join(type, rel);
    this.q.relations.addNode(join);
    if (opts.on) {
      join.on(new And(this._makeClauses(opts.on)));
    }
    if (opts.fields != null) {
      return this.fields(opts.fields);
    }
  };

  SelectQuery.prototype.ensureJoin = function(table, opts) {
    var rel;
    if (opts == null) {
      opts = {};
    }
    /*
        The same as :meth:`join`, but will only join ``tbl`` if it is **not**
        joined already.
    */

    rel = toRelation(table);
    if (!this.q.relations.get(rel.ref(), false)) {
      return this.join(rel, opts);
    }
  };

  SelectQuery.prototype.focus = function(alias) {
    /*
        Make a different table "focused", this will use that table as the default
        for the ``fields``, ``order`` and ``where`` methods.
    
        :param alias: The table/alias name to focus. If the table or alias is not
          already part of the query an error will be thrown.
    */
    return this.q.relations["switch"](alias);
  };

  SelectQuery.prototype.groupBy = function(fields) {
    /* Add a GROUP BY to the query.
    */

    var field, _i, _len;
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      this.q.groupBy.addNode(this.column(field));
    }
    return null;
  };

  SelectQuery.prototype.having = function(constraint) {
    /*
        This method works similarly to :meth:`queries/sud::SUDQuery.where`, but the
        constraints are added the `HAVING` portion of a SQL clause.
    */

    var node, _i, _len, _ref1, _results;
    _ref1 = this._makeClauses(constraint);
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      _results.push(this.q.having.addNode(node));
    }
    return _results;
  };

  return SelectQuery;

})(SUDQuery);

fluid = require('../decorators/fluid');

variadic = require('../decorators/variadic');

deprecate = require('../decorators/deprecate');

_ref1 = ['fields', 'groupBy'];
for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
  method = _ref1[_i];
  SelectQuery.prototype[method] = variadic(SelectQuery.prototype[method]);
}

_ref2 = ['distinct', 'fields', 'func', 'join', 'ensureJoin', 'focus', 'groupBy', 'having'];
for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
  method = _ref2[_j];
  SelectQuery.prototype[method] = fluid(SelectQuery.prototype[method]);
}

SelectQuery.prototype.field = SelectQuery.prototype.fields;

SelectQuery.prototype.agg = deprecate.rename(SelectQuery.prototype.func, ".agg", ".func");
