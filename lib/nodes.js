// Generated by CoffeeScript 1.4.0
/*
These are the classes that represent nodes in the AST for a SQL statement.
Application code should very rarely have to deal with these classes directly;
Instead, the APIs exposed by the various query manager classes are intended to
cover the majority of use-cases.

However, in the spirit of "making hard things possible", all of AST nodes are
exported from this module so you can constructed and assemble them manually if
you need to.
*/

var AbstractAlias, And, Binary, CONST_NODES, Column, ColumnSet, ComparableMixin, Delete, Distinct, Field, FixedNodeSet, GroupBy, Having, Identifier, Insert, IntegerNode, JOIN_TYPES, Join, JoinType, Limit, Node, NodeSet, Offset, Or, OrderBy, Ordering, Parameter, ParenthesizedNodeSet, Prefixed, Relation, RelationSet, Returning, Select, SelectColumnSet, SqlFunction, Statement, TextNode, Tuple, Update, ValueNode, Where, binaryOp, copy, exists, getAlias, k, name, notExists, sqlFunction, text, toColumn, toField, toParam, toProjection, toRelation, tuple, v, _i, _j, _len, _len1, _ref, _ref1, _ref2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

Node = (function() {

  function Node() {}

  /* (Empty) base Node class
  */


  Node.prototype.compile = function(dialect) {
    var message;
    message = "" + this.constructor + " has no compile method. Parents: " + dialect.path;
    throw new Error(message);
  };

  return Node;

})();

ValueNode = (function(_super) {

  __extends(ValueNode, _super);

  /* A ValueNode is a literal string that should be printed unescaped.
  */


  function ValueNode(value) {
    this.value = value;
    if (this.value != null) {
      if (!this.valid()) {
        throw new Error("Invalid " + this.constructor.name + ": " + this.value);
      }
    }
  }

  ValueNode.prototype.copy = function() {
    return new this.constructor(this.value);
  };

  ValueNode.prototype.valid = function() {
    return true;
  };

  ValueNode.prototype.compile = function() {
    return this.value;
  };

  return ValueNode;

})(Node);

IntegerNode = (function(_super) {

  __extends(IntegerNode, _super);

  function IntegerNode() {
    return IntegerNode.__super__.constructor.apply(this, arguments);
  }

  /* A :class:`nodes::ValueNode` that validates it's input is an integer.
  */


  IntegerNode.prototype.valid = function() {
    return !isNaN(this.value = parseInt(this.value));
  };

  return IntegerNode;

})(ValueNode);

Identifier = (function(_super) {

  __extends(Identifier, _super);

  function Identifier() {
    return Identifier.__super__.constructor.apply(this, arguments);
  }

  /*
    An identifier is a column or relation name that may need to be quoted.
  */


  Identifier.prototype.compile = function(dialect) {
    return dialect.quote(this.value);
  };

  return Identifier;

})(ValueNode);

CONST_NODES = {};

_ref = ['DEFAULT', 'NULL', 'IS_NULL', 'IS_NOT_NULL'];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  name = _ref[_i];
  CONST_NODES[name] = new ValueNode(name.replace('_', ' '));
}

JoinType = (function(_super) {

  __extends(JoinType, _super);

  function JoinType() {
    return JoinType.__super__.constructor.apply(this, arguments);
  }

  return JoinType;

})(ValueNode);

JOIN_TYPES = {};

_ref1 = ['LEFT', 'RIGHT', 'INNER', 'LEFT_OUTER', 'RIGHT_OUTER', 'FULL_OUTER', 'NATURAL', 'CROSS'];
for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
  name = _ref1[_j];
  JOIN_TYPES[name] = new JoinType(name.replace('_', ' '));
}

NodeSet = (function(_super) {

  __extends(NodeSet, _super);

  /* A set of nodes joined together by ``@glue``
  */


  function NodeSet(nodes, glue) {
    var node, _k, _len2, _ref2;
    if (glue == null) {
      glue = ' ';
    }
    /*
        :param @nodes: A list of child nodes.
        :param glue: A string that will be used to join the nodes when compileing
    */

    this.nodes = [];
    if (nodes) {
      for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
        node = nodes[_k];
        this.addNode(node);
      }
    }
    if ((_ref2 = this.glue) == null) {
      this.glue = glue;
    }
  }

  NodeSet.prototype.copy = function() {
    /*
        Make a deep copy of this node and it's children
    */

    var c;
    c = new this.constructor(this.nodes.map(copy), this.glue);
    return c;
  };

  NodeSet.prototype.addNode = function(node) {
    /* Add a new Node to the end of this set
    */
    return this.nodes.push(node);
  };

  NodeSet.prototype.compile = function(dialect) {
    var compile;
    compile = dialect.compile.bind(dialect);
    return this.nodes.map(compile).filter(Boolean).join(this.glue);
  };

  return NodeSet;

})(Node);

FixedNodeSet = (function(_super) {

  __extends(FixedNodeSet, _super);

  function FixedNodeSet() {
    FixedNodeSet.__super__.constructor.apply(this, arguments);
    this.addNode = null;
  }

  return FixedNodeSet;

})(NodeSet);

Statement = (function(_super) {

  __extends(Statement, _super);

  Statement.prefix = '';

  Statement.structure = function(structure) {
    var _this = this;
    this._nodeOrder = [];
    return structure.forEach(function(_arg) {
      var k, type;
      k = _arg[0], type = _arg[1];
      _this._nodeOrder.push(k);
      _this.prototype.__defineGetter__(k, function() {
        var _base;
        return (_base = this._private)[k] || (_base[k] = new type);
      });
      return _this.prototype.__defineSetter__(k, function(v) {
        return this._private[k] = v;
      });
    });
  };

  function Statement(opts) {
    this._private = {};
    if (opts) {
      this.initialize(opts);
    }
  }

  Statement.prototype.initialize = function(opts) {
    return this.initialize = null;
  };

  Statement.prototype.copy = function() {
    var c, k, node, _ref2;
    c = new this.constructor;
    _ref2 = this._private;
    for (k in _ref2) {
      node = _ref2[k];
      c[k] = copy(node);
    }
    c.initialize = null;
    return c;
  };

  Statement.prototype.compile = function(dialect) {
    var k, node, parts;
    parts = (function() {
      var _k, _len2, _ref2, _results;
      _ref2 = this.constructor._nodeOrder;
      _results = [];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        k = _ref2[_k];
        if (node = this._private[k]) {
          _results.push(dialect.compile(node));
        }
      }
      return _results;
    }).call(this);
    if (parts.length) {
      return this.constructor.prefix + parts.join(' ');
    } else {
      return "";
    }
  };

  return Statement;

})(Node);

ParenthesizedNodeSet = (function(_super) {

  __extends(ParenthesizedNodeSet, _super);

  function ParenthesizedNodeSet() {
    return ParenthesizedNodeSet.__super__.constructor.apply(this, arguments);
  }

  /* A NodeSet wrapped in parenthesis.
  */


  ParenthesizedNodeSet.prototype.compile = function() {
    return "(" + ParenthesizedNodeSet.__super__.compile.apply(this, arguments) + ")";
  };

  return ParenthesizedNodeSet;

})(NodeSet);

AbstractAlias = (function(_super) {

  __extends(AbstractAlias, _super);

  function AbstractAlias(obj, alias) {
    this.obj = obj;
    this.alias = alias;
  }

  AbstractAlias.prototype.copy = function() {
    return new this.constructor(copy(this.obj), this.alias);
  };

  AbstractAlias.prototype.ref = function() {
    return this.alias;
  };

  AbstractAlias.prototype.compile = function(dialect) {
    return dialect.maybeParens(dialect.compile(this.obj)) + " AS " + dialect.quote(this.alias);
  };

  return AbstractAlias;

})(Node);

TextNode = (function(_super) {
  var Alias, paramRegexp;

  __extends(TextNode, _super);

  function TextNode(text, bindVals) {
    this.text = text;
    this.bindVals = bindVals != null ? bindVals : [];
  }

  paramRegexp = /\$([\w]+)\b/g;

  TextNode.prototype.compile = function(dialect) {
    var _this = this;
    return this.text.replace(paramRegexp, function(_, name) {
      if (name in _this.bindVals) {
        return dialect.parameter(_this.bindVals[name]);
      } else {
        throw new Error("Parameter " + name + " not present in " + (JSON.stringify(_this.bindVals)));
      }
    });
  };

  TextNode.prototype.as = function(alias) {
    return new Alias(this, alias);
  };

  TextNode.prototype.copy = function() {
    return new this.constructor(this.text, copy(this.bindVals));
  };

  TextNode.Alias = Alias = (function(_super1) {

    __extends(Alias, _super1);

    function Alias() {
      return Alias.__super__.constructor.apply(this, arguments);
    }

    return Alias;

  })(AbstractAlias);

  return TextNode;

})(Node);

SqlFunction = (function(_super) {
  var Alias;

  __extends(SqlFunction, _super);

  /* Includes :class:`nodes::ComparableMixin`
  */


  function SqlFunction(name, arglist) {
    this.name = name;
    this.arglist = arglist;
  }

  SqlFunction.prototype.ref = function() {
    return this.name;
  };

  SqlFunction.prototype.copy = function() {
    return new this.constructor(this.name, copy(this.arglist));
  };

  SqlFunction.prototype.compile = function(dialect) {
    return "" + this.name + (dialect.compile(this.arglist));
  };

  SqlFunction.prototype.as = function(alias) {
    return new Alias(this, alias);
  };

  SqlFunction.Alias = Alias = (function(_super1) {
    var shouldRenderFull;

    __extends(Alias, _super1);

    function Alias() {
      return Alias.__super__.constructor.apply(this, arguments);
    }

    shouldRenderFull = function(parents) {
      if (parents.some(function(it) {
        return it instanceof Column;
      })) {
        return false;
      }
      return parents.some(function(node) {
        return node instanceof ColumnSet || node instanceof RelationSet;
      });
    };

    Alias.prototype.compile = function(dialect, parents) {
      if (shouldRenderFull(parents)) {
        return dialect.compile(this.obj) + " AS " + dialect.quote(this.alias);
      } else {
        return dialect.quote(this.alias);
      }
    };

    return Alias;

  })(AbstractAlias);

  return SqlFunction;

})(Node);

Parameter = (function(_super) {

  __extends(Parameter, _super);

  function Parameter() {
    return Parameter.__super__.constructor.apply(this, arguments);
  }

  /*
    Like a ValueNode, but will render as a bound parameter place-holder
    (e.g. ``$1``) and it's value will be collected by the dialect when compiling.
  */


  Parameter.prototype.compile = function(dialect) {
    return dialect.parameter(this.value);
  };

  return Parameter;

})(ValueNode);

Relation = (function(_super) {
  var Alias;

  __extends(Relation, _super);

  function Relation() {
    return Relation.__super__.constructor.apply(this, arguments);
  }

  /*
    A relation node represents a table name or alias in a statement.
  */


  Relation.prototype.ref = function() {
    /*
        Return the table name. Aliased tables return the alias name.
    */
    return this.value;
  };

  Relation.prototype.project = function(field) {
    /* Return a new :class:`nodes::Column` of `field` from this table.
    */
    return new Column(this, toField(field));
  };

  Relation.prototype.as = function(alias) {
    return new Alias(this, alias);
  };

  Relation.Alias = Alias = (function(_super1) {

    __extends(Alias, _super1);

    function Alias() {
      return Alias.__super__.constructor.apply(this, arguments);
    }

    /* An aliased :class:`nodes::Relation`
    */


    Alias.prototype.project = function(field) {
      return Relation.prototype.project.call(this, field);
    };

    Alias.prototype.compile = function(dialect, parents) {
      if (parents.some(function(n) {
        return n instanceof Column;
      })) {
        return dialect.quote(this.alias);
      } else {
        return Alias.__super__.compile.apply(this, arguments);
      }
    };

    return Alias;

  })(AbstractAlias);

  return Relation;

})(Identifier);

Field = (function(_super) {

  __extends(Field, _super);

  /* A column name
  */


  function Field() {
    return Field.__super__.constructor.apply(this, arguments);
  }

  return Field;

})(Identifier);

Column = (function(_super) {
  var Alias;

  __extends(Column, _super);

  /*
    Includes :class:`nodes::ComparableMixin`
  */


  function Column(source, field) {
    this.source = source;
    this.field = field;
    Column.__super__.constructor.call(this, [this.source, this.field], '.');
  }

  Column.prototype.rel = function() {
    return this.source;
  };

  Column.prototype.copy = function() {
    return new this.constructor(copy(this.source), copy(this.field));
  };

  Column.prototype.as = function(alias) {
    return new Alias(this, alias);
  };

  Column.Alias = Alias = (function(_super1) {

    __extends(Alias, _super1);

    function Alias() {
      return Alias.__super__.constructor.apply(this, arguments);
    }

    /* An aliased :class:`nodes::Column`
    */


    Alias.prototype.rel = function() {
      return this.obj.rel();
    };

    Alias.prototype.compile = function(dialect, parents) {
      if (parents.some(function(n) {
        return n instanceof ColumnSet;
      })) {
        return Alias.__super__.compile.apply(this, arguments);
      } else {
        return dialect.quote(this.alias);
      }
    };

    return Alias;

  })(AbstractAlias);

  return Column;

})(FixedNodeSet);

Limit = (function(_super) {

  __extends(Limit, _super);

  function Limit() {
    return Limit.__super__.constructor.apply(this, arguments);
  }

  Limit.prototype.compile = function() {
    if (this.value) {
      return "LIMIT " + this.value;
    } else {
      return "";
    }
  };

  return Limit;

})(IntegerNode);

Offset = (function(_super) {

  __extends(Offset, _super);

  function Offset() {
    return Offset.__super__.constructor.apply(this, arguments);
  }

  Offset.prototype.compile = function() {
    if (this.value) {
      return "OFFSET " + this.value;
    } else {
      return "";
    }
  };

  return Offset;

})(IntegerNode);

Binary = (function(_super) {

  __extends(Binary, _super);

  function Binary(left, op, right) {
    this.left = left;
    this.op = op;
    this.right = right;
    Binary.__super__.constructor.call(this, [this.left, this.op, this.right], ' ');
  }

  Binary.prototype.copy = function() {
    return new this.constructor(copy(this.left), this.op, copy(this.right));
  };

  Binary.prototype.and = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new And([this].concat(__slice.call(args)));
  };

  Binary.prototype.or = function() {
    return new Or([this].concat(__slice.call(args)));
  };

  Binary.prototype.compile = function(dialect) {
    return [dialect.compile(this.left), dialect.operator(this.op), dialect.compile(this.right)].join(' ');
  };

  return Binary;

})(FixedNodeSet);

Tuple = (function(_super) {

  __extends(Tuple, _super);

  function Tuple() {
    return Tuple.__super__.constructor.apply(this, arguments);
  }

  Tuple.prototype.glue = ', ';

  return Tuple;

})(ParenthesizedNodeSet);

ColumnSet = (function(_super) {

  __extends(ColumnSet, _super);

  function ColumnSet() {
    return ColumnSet.__super__.constructor.apply(this, arguments);
  }

  /* The list of projected columns in a query
  */


  ColumnSet.prototype.glue = ', ';

  return ColumnSet;

})(NodeSet);

Returning = (function(_super) {

  __extends(Returning, _super);

  function Returning() {
    return Returning.__super__.constructor.apply(this, arguments);
  }

  Returning.extend = function(klazz) {
    return klazz.prototype.addReturning = function(cols) {
      var col, _k, _len2;
      for (_k = 0, _len2 = cols.length; _k < _len2; _k++) {
        col = cols[_k];
        this.returning.addNode(toField(col));
      }
      return null;
    };
  };

  Returning.prototype.compile = function() {
    var string;
    if (string = Returning.__super__.compile.apply(this, arguments)) {
      return "RETURNING " + string;
    } else {
      return "";
    }
  };

  return Returning;

})(ColumnSet);

Distinct = (function(_super) {

  __extends(Distinct, _super);

  function Distinct(enable) {
    this.enable = enable != null ? enable : false;
    Distinct.__super__.constructor.apply(this, arguments);
  }

  Distinct.prototype.copy = function() {
    return new this.constructor(this.enable, copy(this.nodes));
  };

  Distinct.prototype.compile = function(dialect) {
    if (!this.enable) {
      return '';
    } else if (this.nodes.length) {
      return "DISTINCT(" + Distinct.__super__.compile.apply(this, arguments) + ")";
    } else {
      return 'DISTINCT';
    }
  };

  return Distinct;

})(ColumnSet);

SelectColumnSet = (function(_super) {

  __extends(SelectColumnSet, _super);

  function SelectColumnSet() {
    return SelectColumnSet.__super__.constructor.apply(this, arguments);
  }

  SelectColumnSet.prototype.prune = function(predicate) {
    /*
        Recurse over child nodes, removing all Column nodes that match the
        predicate.
    */
    return this.nodes = this.nodes.filter(function(n) {
      return !predicate(n);
    });
  };

  SelectColumnSet.prototype.compile = function(dialect) {
    if (!this.nodes.length) {
      return '*';
    } else {
      return SelectColumnSet.__super__.compile.apply(this, arguments);
    }
  };

  return SelectColumnSet;

})(ColumnSet);

RelationSet = (function(_super) {

  __extends(RelationSet, _super);

  function RelationSet() {
    return RelationSet.__super__.constructor.apply(this, arguments);
  }

  /*
    Manages a set of relations and exposes methods to find them by alias.
  */


  RelationSet.prototype.addNode = function(node) {
    if (!this.first) {
      this.relsByName = {};
      this.nodes.push(node);
      return this.first = this.active = this.relsByName[node.ref()] = node;
    } else {
      RelationSet.__super__.addNode.apply(this, arguments);
      return this.active = this.relsByName[node.ref()] = node.relation;
    }
  };

  RelationSet.prototype.copy = function() {
    var c, _ref2, _ref3;
    c = RelationSet.__super__.copy.apply(this, arguments);
    if (((_ref2 = this.active) != null ? typeof _ref2.ref === "function" ? _ref2.ref() : void 0 : void 0) !== ((_ref3 = c.active) != null ? typeof _ref3.ref === "function" ? _ref3.ref() : void 0 : void 0)) {
      c["switch"](this.active.ref());
    }
    return c;
  };

  RelationSet.prototype.get = function(name, strict) {
    var found;
    if (strict == null) {
      strict = true;
    }
    if ('string' !== typeof name) {
      name = name.ref();
    }
    found = this.relsByName[name];
    if (strict && !found) {
      throw new Error("No such relation " + name + " in " + (Object.keys(this.relsByName)));
    }
    return found;
  };

  RelationSet.prototype["switch"] = function(name) {
    return this.active = this.get(name);
  };

  RelationSet.prototype.compile = function(dialect) {
    var string;
    if (string = RelationSet.__super__.compile.apply(this, arguments)) {
      return "FROM " + string;
    } else {
      return "";
    }
  };

  return RelationSet;

})(NodeSet);

Join = (function(_super) {
  var JOIN, ON;

  __extends(Join, _super);

  JOIN = new ValueNode('JOIN');

  ON = new ValueNode('ON');

  function Join(type, relation) {
    var nodes;
    this.type = type;
    this.relation = relation;
    nodes = [this.type, JOIN, this.relation];
    Join.__super__.constructor.call(this, nodes);
  }

  Join.prototype.on = function(clause) {
    if (this.nodes.length < 4) {
      this.nodes.push(ON);
    }
    return this.nodes.push(clause);
  };

  Join.prototype.ref = function() {
    return this.relation.ref();
  };

  Join.prototype.copy = function() {
    var c, clause, _k, _len2, _ref2;
    c = new this.constructor(copy(this.type), copy(this.relation));
    _ref2 = this.nodes.slice(4);
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      clause = _ref2[_k];
      c.on(clause);
    }
    return c;
  };

  return Join;

})(FixedNodeSet);

Where = (function(_super) {

  __extends(Where, _super);

  function Where() {
    return Where.__super__.constructor.apply(this, arguments);
  }

  Where.prototype.glue = ' AND ';

  Where.prototype.compile = function(dialect) {
    var string;
    if (string = Where.__super__.compile.apply(this, arguments)) {
      return "WHERE " + string;
    } else {
      return "";
    }
  };

  return Where;

})(NodeSet);

Or = (function(_super) {

  __extends(Or, _super);

  function Or() {
    return Or.__super__.constructor.apply(this, arguments);
  }

  Or.prototype.glue = ' OR ';

  Or.prototype.and = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new And([this].concat(__slice.call(args)));
  };

  Or.prototype.or = function() {
    var arg, args, ret, _k, _len2;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    ret = this.copy();
    for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
      arg = args[_k];
      ret.addNode(arg);
    }
    return ret;
  };

  return Or;

})(ParenthesizedNodeSet);

And = (function(_super) {

  __extends(And, _super);

  function And() {
    return And.__super__.constructor.apply(this, arguments);
  }

  And.prototype.glue = ' AND ';

  And.prototype.and = function() {
    var arg, args, ret, _k, _len2;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    ret = this.copy();
    for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
      arg = args[_k];
      ret.addNode(arg);
    }
    return ret;
  };

  And.prototype.or = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new Or([this].concat(__slice.call(args)));
  };

  return And;

})(ParenthesizedNodeSet);

GroupBy = (function(_super) {

  __extends(GroupBy, _super);

  function GroupBy() {
    return GroupBy.__super__.constructor.apply(this, arguments);
  }

  GroupBy.prototype.glue = ', ';

  GroupBy.prototype.compile = function(dialect) {
    var string;
    if (string = GroupBy.__super__.compile.apply(this, arguments)) {
      return "GROUP BY " + string;
    } else {
      return "";
    }
  };

  return GroupBy;

})(NodeSet);

Having = (function(_super) {

  __extends(Having, _super);

  function Having() {
    return Having.__super__.constructor.apply(this, arguments);
  }

  Having.prototype.glue = ' AND ';

  Having.prototype.compile = function(dialect) {
    var string;
    if (string = Having.__super__.compile.apply(this, arguments)) {
      return "HAVING " + string;
    } else {
      return "";
    }
  };

  return Having;

})(NodeSet);

OrderBy = (function(_super) {

  __extends(OrderBy, _super);

  function OrderBy(orderings) {
    OrderBy.__super__.constructor.call(this, orderings, ', ');
  }

  OrderBy.prototype.compile = function(dialect) {
    var string;
    if (string = OrderBy.__super__.compile.apply(this, arguments)) {
      return "ORDER BY " + string;
    } else {
      return "";
    }
  };

  return OrderBy;

})(NodeSet);

Ordering = (function(_super) {

  __extends(Ordering, _super);

  function Ordering(projection, direction) {
    if (typeof direction === 'string') {
      direction = new ValueNode(direction);
    }
    Ordering.__super__.constructor.call(this, [projection, direction]);
  }

  return Ordering;

})(FixedNodeSet);

Select = (function(_super) {

  __extends(Select, _super);

  /*
    The root node of a SELECT query
  */


  function Select() {
    return Select.__super__.constructor.apply(this, arguments);
  }

  Select.prefix = 'SELECT ';

  Select.structure([['distinct', Distinct], ['projections', SelectColumnSet], ['relations', RelationSet], ['where', Where], ['groupBy', GroupBy], ['having', Having], ['orderBy', OrderBy], ['limit', Limit], ['offset', Offset]]);

  Select.prototype.initialize = function(opts) {
    this.projections;
    if (opts.table) {
      return this.relations.addNode(toRelation(opts.table));
    }
  };

  return Select;

})(Statement);

Update = (function(_super) {
  var UpdateSet;

  __extends(Update, _super);

  /*
    The root node of an UPDATE query
  */


  function Update() {
    return Update.__super__.constructor.apply(this, arguments);
  }

  UpdateSet = (function(_super1) {

    __extends(UpdateSet, _super1);

    function UpdateSet(nodes) {
      UpdateSet.__super__.constructor.call(this, nodes, ', ');
    }

    UpdateSet.prototype.compile = function(dialect) {
      var string;
      if (string = UpdateSet.__super__.compile.apply(this, arguments)) {
        return "SET " + string;
      } else {
        return "";
      }
    };

    return UpdateSet;

  })(NodeSet);

  Update.prefix = 'UPDATE ';

  Update.structure([['relation', Relation], ['updates', UpdateSet], ['orderBy', OrderBy], ['limit', Limit], ['fromList', RelationSet], ['where', Where], ['returning', Returning]]);

  Returning.extend(Update);

  Update.prototype.initialize = function(opts) {
    return this.relation = toRelation(opts.table);
  };

  return Update;

})(Statement);

Insert = (function(_super) {
  var ColumnList, InsertData, valOrDefault;

  __extends(Insert, _super);

  /*
    The root node of an INSERT query
  */


  function Insert() {
    return Insert.__super__.constructor.apply(this, arguments);
  }

  InsertData = (function(_super1) {

    __extends(InsertData, _super1);

    function InsertData() {
      return InsertData.__super__.constructor.apply(this, arguments);
    }

    InsertData.prototype.glue = ', ';

    InsertData.prototype.compile = function(dialect) {
      var string;
      if (string = InsertData.__super__.compile.apply(this, arguments)) {
        return "VALUES " + string;
      } else {
        return "";
      }
    };

    return InsertData;

  })(NodeSet);

  Insert.ColumnList = ColumnList = (function(_super1) {

    __extends(ColumnList, _super1);

    function ColumnList() {
      return ColumnList.__super__.constructor.apply(this, arguments);
    }

    return ColumnList;

  })(Tuple);

  Insert.prefix = 'INSERT INTO ';

  Insert.structure([['relation', Relation], ['columns', ColumnList], ['data', InsertData], ['returning', Returning]]);

  Returning.extend(Insert);

  Insert.prototype.initialize = function(opts) {
    var _ref2;
    if (!((_ref2 = opts.fields) != null ? _ref2.length : void 0)) {
      throw new Error("Column list is required when constructing an INSERT");
    }
    this.columns = new ColumnList(opts.fields.map(toField));
    return this.relation = toRelation(opts.table);
  };

  Insert.prototype.addRow = function(row) {
    if (this.data instanceof Select) {
      throw new Error("Cannot add rows when inserting from a SELECT");
    }
    if (Array.isArray(row)) {
      return this.addRowArray(row);
    } else {
      return this.addRowObject(row);
    }
  };

  Insert.prototype.addRowArray = function(row) {
    var count, message, params, v;
    if (!(count = this.columns.nodes.length)) {
      throw new Error("Must set column list before inserting arrays");
    }
    if (row.length !== count) {
      message = "Wrong number of values in array, expected " + this.columns.nodes;
      throw new Error(message);
    }
    params = (function() {
      var _k, _len2, _results;
      _results = [];
      for (_k = 0, _len2 = row.length; _k < _len2; _k++) {
        v = row[_k];
        if (v instanceof Node) {
          _results.push(v);
        } else {
          _results.push(new Parameter(v));
        }
      }
      return _results;
    })();
    return this.data.addNode(new Tuple(params));
  };

  Insert.prototype.addRowObject = function(row) {
    /*
        Add a row from an object. This will set the column list of the query if it
        isn't set yet. If it `is` set, then only keys matching the existing column
        list will be inserted.
    */

    debugger;    return this.addRowArray(this.columns.nodes.map(valOrDefault.bind(row)));
  };

  valOrDefault = function(field) {
    var key;
    key = field.value;
    if (this.hasOwnProperty(key)) {
      return this[key];
    } else {
      return CONST_NODES.DEFAULT;
    }
  };

  Insert.prototype.from = function(query) {
    if (!(query instanceof Select)) {
      throw new Error("Can only insert from a SELECT");
    }
    return this.data = query;
  };

  return Insert;

})(Statement);

Delete = (function(_super) {

  __extends(Delete, _super);

  /*
    The root node of a DELETE query
  */


  function Delete() {
    return Delete.__super__.constructor.apply(this, arguments);
  }

  Delete.prefix = 'DELETE ';

  Delete.structure([['relations', RelationSet], ['where', Where], ['orderBy', OrderBy], ['limit', Limit], ['returning', Returning]]);

  Returning.extend(Delete);

  Delete.prototype.initialize = function(opts) {
    return this.relations.addNode(toRelation(opts.table));
  };

  return Delete;

})(Statement);

ComparableMixin = (function() {

  function ComparableMixin() {}

  /*
    A mixin that adds comparison methods to a class. Each of these comparison
    methods will yield a new AST node comparing the invocant to the argument.
  */


  ComparableMixin.prototype.eq = function(other) {
    /* ``this = other``
    */
    return this.compare('=', other);
  };

  ComparableMixin.prototype.ne = function(other) {
    /* ``this != other``
    */
    return this.compare('!=', other);
  };

  ComparableMixin.prototype.gt = function(other) {
    /* ``this > other``
    */
    return this.compare('>', other);
  };

  ComparableMixin.prototype.lt = function(other) {
    /* ``this < other``
    */
    return this.compare('<', other);
  };

  ComparableMixin.prototype.lte = function(other) {
    /* ``this <= other``
    */
    return this.compare('<=', other);
  };

  ComparableMixin.prototype.gte = function(other) {
    /* ``this >= other``
    */
    return this.compare('>=', other);
  };

  ComparableMixin.prototype.like = function(other) {
    return this.compare('LIKE', other);
  };

  ComparableMixin.prototype.compare = function(op, other) {
    /* ``this op other`` **DANGER** `op` is **NOT** escaped!
    */
    return new Binary(this, op, toParam(other));
  };

  return ComparableMixin;

})();

_ref2 = ComparableMixin.prototype;
for (k in _ref2) {
  v = _ref2[k];
  TextNode.prototype[k] = v;
  SqlFunction.prototype[k] = v;
  SqlFunction.Alias.prototype[k] = v;
  Column.prototype[k] = v;
  Column.Alias.prototype[k] = v;
  Tuple.prototype[k] = v;
}

toParam = function(it) {
  /*
    Return a Node that can be used as a parameter.
  
      * :class:`queries/select::SelectQuery` instances will be treated as
        un-named sub queries,
      * Node instances will be returned unchanged.
      * Arrays will be turned into a :class:`nodes::Tuple` instance.
  
    All other types will be wrapped in a :class:`nodes::Parameter` instance.
  */

  var SelectQuery;
  SelectQuery = require('./queries/select');
  if ((it != null ? it.constructor : void 0) === SelectQuery) {
    return new Tuple([it.q]);
  } else if (it instanceof Node) {
    return it;
  } else if (Array.isArray(it)) {
    return new Tuple(it.map(toParam));
  } else {
    return new Parameter(it);
  }
};

toRelation = function(it) {
  /*
    Transform ``it`` into a :class:`nodes::Relation` instance.
  
    This accepts `strings, `Relation`` and ``Alias`` instances, and objects with
    a single key-value pair, which will be turned into an ``Alias`` instance.
  
    Examples::
  
       toRelation('table1')     == new Relation('table1')
       toRelation(t1: 'table1') == new Alias(new Relation('table1'), 't1')
  
    **Throws Errors** if the input is not valid.
  */

  var alias;
  switch (it.constructor) {
    case Relation:
    case Relation.Alias:
    case SqlFunction:
    case SqlFunction.Alias:
      return it;
    case String:
      return new Relation(it);
    case Object:
      if (alias = getAlias(it)) {
        return toRelation(it[alias]).as(alias);
      } else {
        throw new Error("Can't make relation out of " + it);
      }
      break;
    default:
      throw new Error("Can't make relation out of " + it);
  }
};

toField = function(it) {
  if (typeof it === 'string') {
    return new Field(it);
  } else if (it instanceof Field) {
    return it;
  } else {
    throw new Error("Can't make a field out of " + it);
  }
};

toColumn = function(relation, field) {
  /*
    Create a new :class:`nodes::Column` instance.
  
    The first argument is optional and specifies a table (or alias) name.
    Alternatively, you can specify the relation name and field with a single
    dot-separated string::
  
      toColumn('departments.name') == toColumn('departments', 'name')
  
    Either argument can be an pre-constructed node object (of the correct type).
  */

  var parts;
  if (field != null) {
    return new Column(toRelation(relation), toField(field));
  } else if (typeof relation === 'string') {
    parts = relation.split('.');
    if (parts.length === 2) {
      return new Column(toRelation(parts[0]), toField(parts[1]));
    }
  }
  throw new Error("Can't make projection from object: " + relation);
};

toProjection = toColumn;

sqlFunction = function(name, args) {
  /*
    Create a new SQL function call node. For example::
  
        count = sqlFunction('count', [new ValueNode('*')])
  */
  return new SqlFunction(name, new Tuple(args.map(toParam)));
};

getAlias = function(o) {
  /*
    Check if ``o`` is an object literal representing an alias, and return the
    alias name if it is.
  */

  var keys;
  if ('object' === typeof o) {
    keys = Object.keys(o);
    if (keys.length === 1) {
      return keys[0];
    }
  }
  return null;
};

text = function(rawSQL, bindVals) {
  /*
    Construct a node with a raw SQL string and (optionally) parameters. Useful for
    when you want to construct a query that is difficult or impossible with the
    normal APIs. [#]_
  
    To use bound parameters in the SQL string, use ``$`` prefixed names, and
    pass a ``bindVals`` argument with corresponding property names. For example,
    :meth:`~queries/sud::SUDQuery.where` doesn't (currently) support the SQL
    ``BETWEEN`` operator, but if you needed it, you could use ``text``::
  
        function peopleInWeightRange (min, max, callback) {
          return select('people')
            .where(text("weight BETWEEN $min AND $max", {min: min, max: max}))
            .execute(callback)
        }
  
    Because javascript doesn't distinguish between array indexing and property
    access, it can be more clear to use numbered parameters for such short
    snippets::
  
        function peopleInWeightRange (min, max, callback) {
          return select('people')
            .where(text("weight BETWEEN $0 AND $1", [min, max]))
            .execute(callback)
        }
  
    If you find yourself using this function often, please consider opening an
    issue on `Github <https://github.com/BetSmartMedia/gesundheit>`_ with details
    on your use case so gesundheit can support it more elegantly.
  */
  return new TextNode(rawSQL, bindVals);
};

binaryOp = function(left, op, right) {
  /*
    Create a new :class:`nodes::Binary` node::
  
      binaryOp('hstore_column', '->', toParam(y))
      # hstore_column -> ?
  
    This is for special cases, normally you want to use the methods from
    :class:`nodes::ComparableMixin`.
  */
  return new Binary(left, op, right);
};

Prefixed = (function(_super) {

  __extends(Prefixed, _super);

  function Prefixed(prefix, node) {
    this.prefix = prefix;
    this.node = node;
  }

  Prefixed.prototype.compile = function() {
    return this.prefix + this.node.compile.apply(this.node, arguments);
  };

  return Prefixed;

})(ValueNode);

exists = function(subquery) {
  /* Create an ``EXISTS (<subquery>)`` node for `where`
  */
  return new Prefixed('EXISTS ', new Tuple([subquery.q || subquery]));
};

notExists = function(subquery) {
  /* Create a ``NOT EXISTS (<subquery>)`` node for `where`
  */
  return new Prefixed('NOT EXISTS ', new Tuple([subquery.q || subquery]));
};

tuple = function(input) {
  /*
    Create a new Tuple from an array of nodes. Any item in the array that is
    **not** an `instanceof Node` will be turned into a parameter with
    :func:`nodes::toParam`.
  */
  return new Tuple(input.map(toParam));
};

module.exports = {
  CONST_NODES: CONST_NODES,
  JOIN_TYPES: JOIN_TYPES,
  binaryOp: binaryOp,
  exists: exists,
  getAlias: getAlias,
  notExists: notExists,
  sqlFunction: sqlFunction,
  text: text,
  toField: toField,
  toParam: toParam,
  toColumn: toColumn,
  toProjection: toProjection,
  toRelation: toRelation,
  tuple: tuple,
  Node: Node,
  ValueNode: ValueNode,
  IntegerNode: IntegerNode,
  Identifier: Identifier,
  JoinType: JoinType,
  NodeSet: NodeSet,
  FixedNodeSet: FixedNodeSet,
  Statement: Statement,
  ParenthesizedNodeSet: ParenthesizedNodeSet,
  TextNode: TextNode,
  SqlFunction: SqlFunction,
  Parameter: Parameter,
  Relation: Relation,
  Field: Field,
  Column: Column,
  Limit: Limit,
  Offset: Offset,
  Binary: Binary,
  Tuple: Tuple,
  ColumnSet: ColumnSet,
  Returning: Returning,
  Distinct: Distinct,
  SelectColumnSet: SelectColumnSet,
  RelationSet: RelationSet,
  Join: Join,
  Where: Where,
  Or: Or,
  And: And,
  GroupBy: GroupBy,
  OrderBy: OrderBy,
  Ordering: Ordering,
  Select: Select,
  Update: Update,
  Insert: Insert,
  Delete: Delete,
  ComparableMixin: ComparableMixin
};

copy = function(it) {
  var c, _results;
  if (!it) {
    return it;
  }
  switch (it.constructor) {
    case String:
    case Number:
    case Boolean:
      return it;
    case Array:
      return it.map(copy);
    case Object:
      c = {};
      _results = [];
      for (k in it) {
        v = it[k];
        _results.push(c[k] = copy(v));
      }
      return _results;
      break;
    default:
      if (it.copy != null) {
        return it.copy();
      } else {
        throw new Error("Don't know how to copy " + it);
      }
  }
};
