// Generated by CoffeeScript 1.4.0
/*
There are a few subsystems that make up gesundheit, but the majority of use
cases will be covered by using the following properties of the main module:

  **gesundheit.{Select, SELECT, select}**
    Function for creating new :class:`queries/select::SelectQuery` instances.

  **gesundheit.{Update, UPDATE, update}**
    Function for creating new :class:`queries/update::UpdateQuery` instances.

  **gesundheit.{Delete, DELETE, delete}**
    Function for creating new :class:`queries/delete::DeleteQuery` instances.

  **gesundheit.{Insert, INSERT, insert}**
    Function for creating new :class:`queries/insert::InsertQuery` instances.

  **gesundheit.engine**
    Function for creating new :mod:`engines`.

  **gesundheit.defaultEngine**
    The engine that will be used for queries that aren't explicitly bound. This
    is set to a no-op engine that you will want to replace with either an object
    returned by the ``gesundheit.engine`` function or by implementing the engine
    interface yourself.

  **Join types**
    Constant nodes for use with :meth:`queries/sud::SUDQuery.join`.
    'LEFT', 'RIGHT', 'INNER', 'LEFT_OUTER', 'RIGHT_OUTER', 'FULL_OUTER'
    'NATURAL', 'CROSS'

  **AST helper functions**
    These come from the `nodes <Nodes>`_ module and are often useful when
    constructing queries that the query manager classes don't cover as well:

      :func:`nodes::toParam`
        Convert any object to a parameter placeholder.
      :func:`nodes::toRelation`
        Convert various inputs to :class:`nodes::Relation` nodes.
      :func:`nodes::binaryOp`
        Create a binary comparison node manually.  (e.g. for postgres' custom
        operators).
      :func:`nodes::sqlFunction`
        Create SQL function calls (e.g. ``MAX(last_update)``)
      :func:`nodes::text`
        Include raw SQL in a query, with parameter placeholders.

If you are implementing support for a different database engine or constructing
particularly unusual SQL statements, you might also want to make use of these:

  **gesundheit.nodes**
    The `nodes <Nodes>` module.

  **gesundheit.dialects**
    The `dialects <Dialects>` module.
*/

var helper, name, node, _ref, _ref1, _ref2,
  __slice = [].slice;

exports.dialects = require('./dialects');

exports.engine = require('./engine');

exports.defaultEngine = exports.engine('fake://localhost/');

exports.nodes = require('./nodes');

_ref = exports.nodes.CONST_NODES;
for (name in _ref) {
  node = _ref[name];
  exports[name] = exports.nodes.CONST_NODES[name];
}

_ref1 = exports.nodes.JOIN_TYPES;
for (name in _ref1) {
  node = _ref1[name];
  exports[name] = exports.nodes.JOIN_TYPES[name];
}

_ref2 = exports.nodes;
for (name in _ref2) {
  helper = _ref2[name];
  if (name[0] === name[0].toLowerCase()) {
    exports[name] = helper;
  }
}

require('./queries').mixinFactoryMethods(exports, function() {
  return exports.defaultEngine;
});

exports.begin = function() {
  var args, _ref3;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return (_ref3 = exports.defaultEngine).begin.apply(_ref3, args);
};

exports.query = function() {
  var args, _ref3;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return (_ref3 = exports.defaultEngine).query.apply(_ref3, args);
};
