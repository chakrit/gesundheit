// Generated by CoffeeScript 1.4.0
/*
Dialects are responsible for compiling an AST to a SQL string compatible with
a particular DBMS. They are rarely used directly, instead a query is usually
bound to an `engine <Engines>`_ that will delegate compiling to it's dialect
instance.
*/

var BaseDialect, Delete, Insert, MySQLDialect, PostgresDialect, SQLite3Dialect, Select, Update, keywords, kwFile, read, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

read = require('fs').readFileSync;

kwFile = __dirname + '/sql_keywords.txt';

keywords = read(kwFile, 'ascii').split('\n').filter(Boolean);

_ref = require('./nodes'), Select = _ref.Select, Update = _ref.Update, Delete = _ref.Delete, Insert = _ref.Insert;

BaseDialect = (function() {
  var Visitor, doubleQuote, needsQuote;

  function BaseDialect() {}

  BaseDialect.prototype.reset = function() {};

  BaseDialect.prototype.compile = function(root) {
    var text, visitor;
    visitor = new Visitor(this);
    text = visitor.compile(root);
    return [text, visitor.params];
  };

  BaseDialect.prototype.renderString = function(s) {
    var path;
    path = this.path.map(function(p) {
      var _ref1;
      return (_ref1 = p.constructor) != null ? _ref1.name : void 0;
    }).join(' > ');
    this.path = [];
    throw new Error("raw string compiled! " + path);
  };

  needsQuote = /\s|"|\./;

  doubleQuote = /"/g;

  BaseDialect.prototype.quote = function(s) {
    if ((s != null ? s.match(needsQuote) : void 0) || this.isKeyword(s)) {
      return '"' + s.replace(doubleQuote, '\\"') + '"';
    } else {
      return s;
    }
  };

  BaseDialect.prototype.isKeyword = function(word) {
    return keywords.indexOf(word.toUpperCase()) !== -1;
  };

  BaseDialect.prototype.operator = function(op) {
    switch (op.toLowerCase()) {
      case 'ne':
      case '!=':
      case '<>':
        return '!=';
      case 'eq':
      case '=':
        return '=';
      case 'lt':
      case '<':
        return '<';
      case 'gt':
      case '>':
        return '>';
      case 'lte':
      case '<=':
        return '<=';
      case 'gte':
      case '>=':
        return '>=';
      case 'like':
        return 'LIKE';
      case 'ilike':
        return 'ILIKE';
      case 'in':
        return 'IN';
      case 'notin':
        return 'NOT IN';
      case 'is':
        return 'IS';
      default:
        throw new Error("Unsupported comparison operator: " + op);
    }
  };

  BaseDialect.prototype.placeholder = function(position) {
    return "$" + position;
  };

  Visitor = (function() {

    function Visitor(dialect) {
      this.dialect = dialect;
      this.path = [];
      this.params = [];
    }

    Visitor.prototype.compile = function(node) {
      var custom, name, string, _ref1, _ref2;
      this.path.push(node);
      name = node != null ? (_ref1 = node.__proto__) != null ? (_ref2 = _ref1.constructor) != null ? _ref2.name : void 0 : void 0 : void 0;
      if (name && (custom = this.dialect['render' + name])) {
        string = custom.call(this, node);
      } else {
        string = node.compile(this, this.path);
      }
      this.path.pop(node);
      return string;
    };

    Visitor.prototype.maybeParens = function(it) {
      if (/\s/.exec(it)) {
        return "(" + it + ")";
      } else {
        return it;
      }
    };

    Visitor.prototype.operator = function(string) {
      return this.dialect.operator(string);
    };

    Visitor.prototype.parameter = function(val) {
      this.params.push(val);
      return this.dialect.placeholder(this.params.length);
    };

    Visitor.prototype.quote = function(string) {
      return this.dialect.quote(string, this.path);
    };

    return Visitor;

  })();

  return BaseDialect;

})();

PostgresDialect = (function(_super) {

  __extends(PostgresDialect, _super);

  function PostgresDialect() {
    return PostgresDialect.__super__.constructor.apply(this, arguments);
  }

  PostgresDialect.prototype.operator = function(op) {
    switch (op.toLowerCase()) {
      case 'hasKey':
        return '?';
      case '->':
        return '->';
      default:
        return PostgresDialect.__super__.operator.call(this, op);
    }
  };

  PostgresDialect.prototype.isKeyword = function(s) {
    return (s != null) && s !== '*';
  };

  return PostgresDialect;

})(BaseDialect);

MySQLDialect = (function(_super) {

  __extends(MySQLDialect, _super);

  function MySQLDialect() {
    return MySQLDialect.__super__.constructor.apply(this, arguments);
  }

  MySQLDialect.prototype.placeholder = function() {
    return '?';
  };

  MySQLDialect.prototype.quote = function(s, path) {
    /* Do not quote column names in insert column list
    */
    if (path.some(function(node) {
      return node instanceof Insert.ColumnList;
    })) {
      return s;
    } else {
      return MySQLDialect.__super__.quote.apply(this, arguments);
    }
  };

  return MySQLDialect;

})(BaseDialect);

SQLite3Dialect = (function(_super) {

  __extends(SQLite3Dialect, _super);

  function SQLite3Dialect() {
    return SQLite3Dialect.__super__.constructor.apply(this, arguments);
  }

  SQLite3Dialect.prototype.placeholder = function() {
    return '?';
  };

  SQLite3Dialect.prototype.renderInsertData = function(node) {
    var string;
    if (node.nodes.length < 2) {
      return node.compile(this, this.path);
    } else {
      node.glue = ' UNION ALL SELECT ';
      string = node.compile(this, this.path).replace('VALUES', 'SELECT').replace(/[()]/g, '');
      node.glue = ', ';
      return string;
    }
  };

  return SQLite3Dialect;

})(BaseDialect);

module.exports = {
  base: BaseDialect,
  postgres: PostgresDialect,
  mysql: MySQLDialect,
  sqlite3: SQLite3Dialect
};
